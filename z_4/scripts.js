var element = document.querySelector("#target");
let text =
  "Приведу часть финальной таблицы, для наглядного пояснения: «Стоимость» одной итерации возросла до 4 баллов, однако эффективность сильно возросла. Тратя первой комбинацией 28 баллов мы получали увеличение в 256 раз, а для второй комбинации эта цифра возросла до 2187 раз! Причем с каждой следующей итерацией коэффициент различия увеличений возрастает на треть! Очень неплохо! А можно ли еще?... А можно ли еще? — этот вопрос мучал меня всю сегодняшнюю ночь! Рассчитать первые две комбинации в уме, и убедиться в резонности внесения изменений было не сложно. Но узнать, в какой же момент увеличение комбинации приведет к регрессу, считая каждую итерацию для каждой комбинации в голове, я не смог. Если бы смог — то сейчас Вам не пришлось бы читать всю эту ересь :) Оптимальную комбинацию получилось найти довольно быстно, но остановится я смог, только когда заметил явное понижение коэффициента увеличения. Для этого хватило десяти комбинаций. И вот самое заметное понижение «КПД» — 10я комбинация, тратя 48 баллов усилий, мы получаем увеличение в 1 771 561 раз. Почти 2 миллиона, не кисло! И все бы ничего, если бы не 8я комбинация, при 49 баллах получающая 4 782 969. «Стой, как же так» — скажете Вы — «в 10й комбинации мы тратили всего 48 баллов, и получали почти 2 млн. А тут, хоть результат и близится к 5 млн, но баллов уже 49!» Да, но можете расслабится — добавление дополнительного балла в 10ю комбинацию — это всего 2 нажатия Ctrl+V (напомню, одно нажатие на тот момент увеличивает результат на 161 051. т.е. два нажатия — это чуть больше 320 тысяч, которые нас уже не спасут) Кроме того, если уж желать полного совпадения, то все та же 10я комбинация и 48 баллов (1 771 561), так же не выдерживает соперничества и с 6й комбинацией, у которой при 48 баллах набирается 5 764 801 увеличений. Для меня этих данных было более чем достаточно, чтобы разобраться, как быстрее всего копипастить :) Ниже, как обещал, прикладываю полную таблицу, с подробным расчетом каждой комбинации.";

var Visible = function (target) {
  // Все позиции элемента
  var targetPosition = {
      top: window.pageYOffset + target.getBoundingClientRect().top,
      left: window.pageXOffset + target.getBoundingClientRect().left,
      right: window.pageXOffset + target.getBoundingClientRect().right,
      bottom: window.pageYOffset + target.getBoundingClientRect().bottom,
    },
    // Получаем позиции окна
    windowPosition = {
      top: window.pageYOffset,
      left: window.pageXOffset,
      right: window.pageXOffset + document.documentElement.clientWidth,
      bottom: window.pageYOffset + document.documentElement.clientHeight,
    };

  if (
    targetPosition.bottom > windowPosition.top && // Если позиция нижней части элемента больше позиции верхней чайти окна, то элемент виден сверху
    targetPosition.top < windowPosition.bottom && // Если позиция верхней части элемента меньше позиции нижней чайти окна, то элемент виден снизу
    targetPosition.right > windowPosition.left && // Если позиция правой стороны элемента больше позиции левой части окна, то элемент виден слева
    targetPosition.left < windowPosition.right
  ) {
    // Если позиция левой стороны элемента меньше позиции правой чайти окна, то элемент виден справа
    // Если элемент полностью видно, то запускаем следующий код
    sleep(2000);
    let newElem = document.createElement("div");
    newElem.textContent = text;
    element.remove();
    document.body.append(newElem);
  } else {
    // Если элемент не видно, то запускаем этот код
    console.clear();
  }
};

// Запускаем функцию при прокрутке страницы
window.addEventListener("scroll", function () {
  Visible(element);
});

// А также запустим функцию сразу. А то вдруг, элемент изначально видно
Visible(element);

function sleep(milliseconds) {
  const date = Date.now();
  let currentDate = null;
  do {
    currentDate = Date.now();
  } while (currentDate - date < milliseconds);
}
